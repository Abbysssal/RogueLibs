// table of contents

## Custom Names ##

`CustomName` class represents in-game localization strings. They consist of their `Name`, `Type` and a collection of translated strings.

Here's how you can add custom localization strings to the game:

```cs
public static CustomName CreateCustomName(string name, string type, CustomNameInfo info);
```

#### `CustomNameInfo` ####

`CustomNameInfo` is a mutable structure, that just holds a collection of translated strings. You can use it to create instances of `CustomName` class or just pass information to other methods.

```cs
RogueLibs.CreateCustomName("Name", "Type", new CustomNameInfo("english text"));
```

Or:

```cs
RogueLibs.CreateCustomName("Name", "Type", new CustomNameInfo
    {
        English = "english text",
        Brazilian = "brazilian text",
        [LanguageCode.French] = "french text",
        [(LanguageCode)12345] = "custom language text"
    });
```

`LanguageCode` enumeration represents different languages. Both `CustomName` and `CustomNameInfo` have an indexer property, that allows you to get and set the stored translations:

```cs
CustomName name = ...;
string translation = name[(LanguageCode)12345];
// returns null, if that language is not specified
string display = translation ?? name.English;
```

#### Custom Languages ####

Adding your own custom language is as easy as calling this method:

```cs
CustomName.RegisterLanguageCode("custom", (LanguageCode)12345);
```

After that, you will be able to select your language in the game's settings.

***TODO: Add custom languages to the game's settings menu.***

## Custom Sprites ##

`RogueSprite` class represents a custom sprite in the game. Since Streets of Rogue uses Toolkit 2D, you can't just add a regular `UnityEngine.Sprite` and use it everywhere you need.

```cs
public static RogueSprite CreateCustomSprite(string name, SpriteScope scope, byte[] rawData, float ppu = 64f);
public static RogueSprite CreateCustomSprite(string name, SpriteScope scope, byte[] rawData, Rect region, float ppu = 64f);
```

The `scope` parameter specifies the area of the game, that the sprite will be integrated into. Use `SpriteScope.Items` for item sprites, `SpriteScope.Objects` for object sprites and etc.

You can specify the sprite's PPU (Pixels-Per-Unit) ratio, and even the region that the custom sprite will use (idk why you would need that, but I added it anyway).

#### Adding sprites to your project ####

You're probably thinking *"Okay, yeah, but what about that `rawData` parameter? Do I just create an array and fill it with all thousands of bytes of the image?"*, - Well, yeah, you can do that, but you can also add the image to your project's resources and then reference it from the code.

First, your image should be PNG or JPEG. Change the image file's extension to ".bin" (but don't do anything else). Then go to your project's Properties > Resources and add that .bin file to the resources. It will be recognized as a binary data file and you will be able to reference it as `byte[]` in the code:

```cs
RogueLibs.CreateCustomSprite("MyItem", SpriteScope.Items, Properties.Resources.MyItem);
```

## Custom Unlocks ##

Unlocks are a little bit more complicated.

`UnlockWrapper` represents an unlock wrapper, an object, that wraps around the `Unlock` class. It is available for both custom and original unlocks:

```cs
public static UnlockWrapper GetUnlock(string name, string type);
public static TUnlock GetUnlock<TUnlock>(string name) where TUnlock : UnlockWrapper;
```

#### `DisplayedUnlock` ####

`DisplayedUnlock` derives from `UnlockWrapper` and represents an unlock, that can be displayed in `ScrollingMenu`, `CharacterCreation` or `LevelEditor` menus. They have extra methods for interacting with the interface, other unlocks in the menu and stuff like that.

If you want to create a simple unlock, without any special interactions or properties, just use `MutatorUnlock`, `ItemUnlock`, `TraitUnlock`, `AbilityUnlock` and other classes:

```cs
RogueLibs.CreateCustomUnlock(new MutatorUnlock("RidiculousKnockback") { UnlockCost = 5 });
```

If you want to make something more complicated, create a new class deriving from `MutatorUnlock` or any other unlock class:

```cs
public class MyMutator : MutatorUnlock
{
    public override OnPushedButton()
    {
        // ...
    }
}
```

When overriding methods, you can check the RogueLibs' source code of the unlock classes to make sure you've done everything right.

***TODO: More info on how custom unlocks work.***